\hypertarget{benchmark__kernels_8cpp}{}\section{src/benchmark/benchmark\+\_\+kernels/benchmark\+\_\+kernels.cpp File Reference}
\label{benchmark__kernels_8cpp}\index{src/benchmark/benchmark\+\_\+kernels/benchmark\+\_\+kernels.\+cpp@{src/benchmark/benchmark\+\_\+kernels/benchmark\+\_\+kernels.\+cpp}}


Implementation file for benchmark kernel functions for doing the actual work we care about. \+:)  


{\ttfamily \#include \char`\"{}benchmark\+\_\+kernels.\+h\char`\"{}}\\*
{\ttfamily \#include $<$common/common.\+h$>$}\\*


\subsection{Detailed Description}
Implementation file for benchmark kernel functions for doing the actual work we care about. \+:) 

Optimization tricks include\+:
\begin{DoxyItemize}
\item U\+N\+R\+O\+L\+L macros to manual loop unrolling. This reduces the relative branch overhead of the loop. We don\textquotesingle{}t want to benchmark loops, we want to benchmark memory! But unrolling too much can hurt code size and instruction locality, potentially decreasing I-\/cache utilization and causing extra overheads. This is why we allow multiple unroll lengths at compile-\/time.
\item volatile keyword to prevent compiler from optimizing the code and removing instructions that we need. The compiler is too smart for its own good! 
\end{DoxyItemize}