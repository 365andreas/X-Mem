\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark}{}\section{xmem\+:\+:benchmark\+:\+:Throughput\+Benchmark Class Reference}
\label{classxmem_1_1benchmark_1_1_throughput_benchmark}\index{xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}}


A type of benchmark that measures memory throughput either via sequential, strided sequential, or random access patterns.  




{\ttfamily \#include $<$Throughput\+Benchmark.\+h$>$}

Inheritance diagram for xmem\+:\+:benchmark\+:\+:Throughput\+Benchmark\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classxmem_1_1benchmark_1_1_throughput_benchmark}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_a21095b46866ebe68c75c3be14471a7b5}{}typedef int32\+\_\+t($\ast$ {\bfseries Throughput\+Bench\+Function}) (void $\ast$, void $\ast$)\label{classxmem_1_1benchmark_1_1_throughput_benchmark_a21095b46866ebe68c75c3be14471a7b5}

\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classxmem_1_1benchmark_1_1_throughput_benchmark_a7f6fcc030500ebd3aed37d7eacea68dc}{Throughput\+Benchmark} (void $\ast$mem\+\_\+array, size\+\_\+t len, uint32\+\_\+t iterations, xmem\+::common\+::chunk\+\_\+size\+\_\+t chunk\+\_\+size, uint32\+\_\+t cpu\+\_\+node, uint32\+\_\+t mem\+\_\+node, uint32\+\_\+t num\+\_\+worker\+\_\+threads, std\+::string name, \hyperlink{classxmem_1_1timers_1_1_timer}{xmem\+::timers\+::\+Timer} $\ast$timer, std\+::vector$<$ \hyperlink{classxmem_1_1power_1_1_power_reader}{xmem\+::power\+::\+Power\+Reader} $\ast$ $>$ dram\+\_\+power\+\_\+readers, int64\+\_\+t stride\+\_\+size, xmem\+::common\+::pattern\+\_\+mode\+\_\+t pattern\+\_\+mode, xmem\+::common\+::rw\+\_\+mode\+\_\+t rw\+\_\+mode)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classxmem_1_1benchmark_1_1_throughput_benchmark_a9f113e51d980830582148eb05c8810a3}{run} ()
\begin{DoxyCompactList}\small\item\em Runs the benchmark. \end{DoxyCompactList}\item 
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_aab821d4beb68616c5a939bc2e493426e}{}virtual void \hyperlink{classxmem_1_1benchmark_1_1_throughput_benchmark_aab821d4beb68616c5a939bc2e493426e}{report\+\_\+benchmark\+\_\+info} ()\label{classxmem_1_1benchmark_1_1_throughput_benchmark_aab821d4beb68616c5a939bc2e493426e}

\begin{DoxyCompactList}\small\item\em Reports benchmark configuration details to the console. \end{DoxyCompactList}\item 
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_a7df909bd544d1399e756a98bfbce2561}{}virtual void \hyperlink{classxmem_1_1benchmark_1_1_throughput_benchmark_a7df909bd544d1399e756a98bfbce2561}{report\+\_\+results} ()\label{classxmem_1_1benchmark_1_1_throughput_benchmark_a7df909bd544d1399e756a98bfbce2561}

\begin{DoxyCompactList}\small\item\em Reports results to the console. \end{DoxyCompactList}\item 
int64\+\_\+t \hyperlink{classxmem_1_1benchmark_1_1_throughput_benchmark_ad31b0fecafb174be0509581cda099d55}{get\+Stride\+Size} ()
\begin{DoxyCompactList}\small\item\em Gets the stride size for this benchmark. \end{DoxyCompactList}\item 
xmem\+::common\+::pattern\+\_\+mode\+\_\+t \hyperlink{classxmem_1_1benchmark_1_1_throughput_benchmark_a2c7dc699b2ae013edd9de871778dff7b}{get\+Pattern\+Mode} ()
\begin{DoxyCompactList}\small\item\em Gets the pattern mode for this benchmark. \end{DoxyCompactList}\item 
xmem\+::common\+::rw\+\_\+mode\+\_\+t \hyperlink{classxmem_1_1benchmark_1_1_throughput_benchmark_acd839b1c7a1d51ff3ce7921a36d65e98}{get\+R\+W\+Mode} ()
\begin{DoxyCompactList}\small\item\em Gets the read/write mode for this benchmark. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A type of benchmark that measures memory throughput either via sequential, strided sequential, or random access patterns. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_a7f6fcc030500ebd3aed37d7eacea68dc}{}\index{xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}!Throughput\+Benchmark@{Throughput\+Benchmark}}
\index{Throughput\+Benchmark@{Throughput\+Benchmark}!xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}}
\subsubsection[{Throughput\+Benchmark}]{\setlength{\rightskip}{0pt plus 5cm}Throughput\+Benchmark\+::\+Throughput\+Benchmark (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{mem\+\_\+array, }
\item[{size\+\_\+t}]{len, }
\item[{uint32\+\_\+t}]{iterations, }
\item[{xmem\+::common\+::chunk\+\_\+size\+\_\+t}]{chunk\+\_\+size, }
\item[{uint32\+\_\+t}]{cpu\+\_\+node, }
\item[{uint32\+\_\+t}]{mem\+\_\+node, }
\item[{uint32\+\_\+t}]{num\+\_\+worker\+\_\+threads, }
\item[{std\+::string}]{name, }
\item[{{\bf xmem\+::timers\+::\+Timer} $\ast$}]{timer, }
\item[{std\+::vector$<$ {\bf xmem\+::power\+::\+Power\+Reader} $\ast$ $>$}]{dram\+\_\+power\+\_\+readers, }
\item[{int64\+\_\+t}]{stride\+\_\+size, }
\item[{xmem\+::common\+::pattern\+\_\+mode\+\_\+t}]{pattern\+\_\+mode, }
\item[{xmem\+::common\+::rw\+\_\+mode\+\_\+t}]{rw\+\_\+mode}
\end{DoxyParamCaption}
)}\label{classxmem_1_1benchmark_1_1_throughput_benchmark_a7f6fcc030500ebd3aed37d7eacea68dc}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em mem\+\_\+array} & a pointer to a contiguous chunk of memory that has been allocated for benchmarking among the worker threads. This should be aligned to a 256-\/bit boundary and should be the working set size times number of threads large. \\
\hline
{\em len} & Length of the raw\+\_\+mem\+\_\+array in bytes. This should be a multiple of 4 K\+B pages. \\
\hline
{\em iterations} & Number of iterations (passes) to do of the complete benchmark. \\
\hline
{\em chunk\+\_\+size} & encoded size of an individual memory access. \\
\hline
{\em cpu\+\_\+node} & the logical C\+P\+U N\+U\+M\+A node to use in the benchmark \\
\hline
{\em mem\+\_\+node} & the logical memory N\+U\+M\+A node used in the benchmark \\
\hline
{\em num\+\_\+worker\+\_\+threads} & number of worker threads to use in the benchmark \\
\hline
{\em name} & name of the benchmark to use when reporting \\
\hline
{\em timer} & pointer to an existing Timer object \\
\hline
{\em dram\+\_\+power\+\_\+readers} & vector of pointers to Power\+Reader objects for measuring D\+R\+A\+M power \\
\hline
{\em stride\+\_\+size} & For sequential access patterns, the stride counted in chunks. Negative values mean reverse access pattern. A stride of 1 is purely sequential. \\
\hline
{\em pattern\+\_\+mode} & Indicates sequential or random access. \\
\hline
{\em rw\+\_\+mode} & Indicates reads or writes. T\+O\+D\+O\+: allow for a mixture \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_a2c7dc699b2ae013edd9de871778dff7b}{}\index{xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}!get\+Pattern\+Mode@{get\+Pattern\+Mode}}
\index{get\+Pattern\+Mode@{get\+Pattern\+Mode}!xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}}
\subsubsection[{get\+Pattern\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}pattern\+\_\+mode\+\_\+t Throughput\+Benchmark\+::get\+Pattern\+Mode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classxmem_1_1benchmark_1_1_throughput_benchmark_a2c7dc699b2ae013edd9de871778dff7b}


Gets the pattern mode for this benchmark. 

\begin{DoxyReturn}{Returns}
The pattern mode enumerator. 
\end{DoxyReturn}
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_acd839b1c7a1d51ff3ce7921a36d65e98}{}\index{xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}!get\+R\+W\+Mode@{get\+R\+W\+Mode}}
\index{get\+R\+W\+Mode@{get\+R\+W\+Mode}!xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}}
\subsubsection[{get\+R\+W\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}rw\+\_\+mode\+\_\+t Throughput\+Benchmark\+::get\+R\+W\+Mode (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classxmem_1_1benchmark_1_1_throughput_benchmark_acd839b1c7a1d51ff3ce7921a36d65e98}


Gets the read/write mode for this benchmark. 

\begin{DoxyReturn}{Returns}
The read/write mix mode. 
\end{DoxyReturn}
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_ad31b0fecafb174be0509581cda099d55}{}\index{xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}!get\+Stride\+Size@{get\+Stride\+Size}}
\index{get\+Stride\+Size@{get\+Stride\+Size}!xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}}
\subsubsection[{get\+Stride\+Size}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t Throughput\+Benchmark\+::get\+Stride\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classxmem_1_1benchmark_1_1_throughput_benchmark_ad31b0fecafb174be0509581cda099d55}


Gets the stride size for this benchmark. 

\begin{DoxyReturn}{Returns}
The stride size in chunks. 
\end{DoxyReturn}
\hypertarget{classxmem_1_1benchmark_1_1_throughput_benchmark_a9f113e51d980830582148eb05c8810a3}{}\index{xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}!run@{run}}
\index{run@{run}!xmem\+::benchmark\+::\+Throughput\+Benchmark@{xmem\+::benchmark\+::\+Throughput\+Benchmark}}
\subsubsection[{run}]{\setlength{\rightskip}{0pt plus 5cm}bool Throughput\+Benchmark\+::run (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classxmem_1_1benchmark_1_1_throughput_benchmark_a9f113e51d980830582148eb05c8810a3}


Runs the benchmark. 

\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}


Implements \hyperlink{classxmem_1_1benchmark_1_1_benchmark_aa0dbe60e525457770c835c6c72a0be6a}{xmem\+::benchmark\+::\+Benchmark}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/benchmark/\hyperlink{_throughput_benchmark_8h}{Throughput\+Benchmark.\+h}\item 
src/benchmark/\hyperlink{_throughput_benchmark_8cpp}{Throughput\+Benchmark.\+cpp}\end{DoxyCompactItemize}
